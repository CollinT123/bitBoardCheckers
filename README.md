# Bit Board Checkers
>To run open the checkers_game executable
>
>This project was made for school to learn low level programming techniques such as bit manipulation, bit shifting, and boolean algebra. I also learned about memory management.
From here I will detail the major functions in the order in which they were written, and some of the problems that arose from each.  

# InitializeBoards
> This was the first function I wrote, and my first experience using bitwise operations. Its job is to set up the bitboards: to have all locations of pieces be 1 and in the correct location. I decided to assign them row by row. This initial method taught me the basics to bit flipping, and how efficient programing at this level can be.
# PrintBoard
> Next, I needed a way to view the bitboard I had created, and all I did was print the board from top to bottom, checking both boards to see if a piece was there, printing an r for red piece, b for black piece, and a – for a blank space. I initially implemented it printing from the bottom to the top, but when viewed from the user’s point of view this would make the board upside down. I then had to reverse the printing order. I later added digits to the bottom and letters to the left to make it easier to identify which space you wanted to move. Following this, I added the ability to display queens pieces, indentified by a capital letter.
# ConvertMoveToBitBoard
> Before I could begin to allow my pieces to move I needed a way to easily convert the user input into something the bitboard could understand. Users would enter a letter row followed by a number collumn. I had the rows become numbers 0-7. The formula I used was row*8+collumn. This would give the accurate bit needed in my array.
# Move Pieces
> First, I want to highlight all the methods that were created to help check validity of movement. I created one for each color since they needed to be moved in different directions, and I could not figure out a formula that would allow for both colors to be checked efficiently inside of the same method.
## CheckIfPieceExists
> This method was simple, it checks the array passed to it and a location. It then returns if there is a piece at that bit in the bitBoard.
## CheckIfValidMove
> This is where the bulk of the checking happens. The method is passed four parameters, bitBoardToMove, BitBoardToCheck, spaceToMove, and pieceToMove. It first checks to see if the move is diagonal, first checking if the space to move is 7 or 9 bits higher, and then 14 and 18 bits higher than pieceToMove. Then, if the space its trying to move to is not occupied. If it passes both these checks, we move to the second step, checking if it is a jump. If it is not it returns a valid move, but if it is more checks are needed. If it is a jump we have to make sure that it is attempting to jump over a piece. This is done by checking that the bits 7 or 9 higher contain an opposing piece. If this is true then it returns that it is a valid move. I was able to simplify the if statement for this using boolean algebra.
## MovePieceRed
> I initially wanted to handle standard movement without jumping. My plan for this was to have the ability to get the user choice of piece and check if the piece is valid, then get the location and check if that was valid. It accepts four conditions, bitBoardToMove, bitBoardToCheck, initialSpaceInBitBoard, and bitBoardQueen. Everything but the initialSpaceInBitBoard is fairly self explanatory. The initialSpaceInBitBoard is used to recursively call the method in the case of a double jump. The initialSpace is set to 64 when we need to ask what piece the user wants to move, any other value will result in it skipping that section of code.

> The first thing the method does is check if it needs to ask the user what the initialSpace is. If it does it asks the user for the space it wants to move, and verifies that it exists using the CheckIfPieceExists. It will then check if the piece is a queen using the queenBitBoard. I will detail more on queen movement later. I then ask for the location the player wants to move to, check if it is valid, and then proceed. I check to see if the user is attempting a jump, and if they are I set the attemptingJump variable to 1. I move the piece, flipping the bit at the current position to 0 and the new position to 1. Then if I made a jump, I flip the bit in the bitBoardToCheck to 0, removing the piece. I then check for a double jump. This is where the majority of my problems came from as the double jump led to a lot of bugs. I first check that the user attempted a jump. I then check to see if the if piece either 21 or 27 bits higher than the player’s initial space is occupied. If it is I then check to see if the space that would make the jump possible is occupied. If it is not then I allow the user to double jump recursively calling the method again.
# Queens
> The last thing I did was introduce the ability to create Queens. My idea was to create another bitBoard that kept track of all the Queens on the board. Since two queens could not occupy the same space I would not need to know what color the queen was since I could reference that position in the red or black bitboard to know what kind of piece it was. I broke the problem down into two methods, one to identify and set the queens, and the other to move them.
## CreateQueens
> The createQueens method was fairly simple to design. I accept the red, black, and queen bitboard. I then check the final rows for each bitboard, creating queens any time a piece makes it to the other side.
# MoveQueen
> Queen movement utilized a lot of the previous code that I had done, and was able to be done without having to differentiate by color. First, I check to make sure that the piece selected wants to move to a valid space. I do this by checking both color’s validMove functions. Since the piece can move in any direction, if I check both colors, that checks all possible moves in both directions. I check to see if the player is attempting a jump by checking if the spaceToMove is 9 bits larger or smaller than the current position. I then move the piece in both the queenBoard and the colorBoard. I then check to see if the player is attempting to double jump by checking both color’s conditions. If a double jump is valid then I recursively call the queen method again.